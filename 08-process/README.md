# Processes

In this step we add capabilities to load and run user programs.

We add a user directory with a simple `init` program to test our first user
space running program (or *process*).

## Process creation

In `task.c` we add the `create_process()` function. Processes has *process
identifiers (pid)*.

To create a process edos makes the following steps:

1. Create a task. We need to configure the task context to start in
   `start_process()` kernel function and use the task kernel mode stack. When
   `scheduler()` select this task, it will switch to task saved context and
   jumps to `start_process()`. This function will follows an execution path to a
   trap return via `return_to_user_mode()`. This set the CPU status registers to
   return to user mode when `u_trap_ret()` execute `sret` instruction.
2. Call to `exec(task, path, args)` function which load the program code and
   data sections, allocate one page for the user mode stack and push program
   command line arguments on it. Finally, `exec()` sets the task *thread
   context* and a *trap frame* to return from trap to user mode. The low level
   `u_trap_ret` routine will return to start of user program entry point and the
   corrsponding *stack pointer*.

## Address space for processes

Processes will use a virtual address space in $[PROC_MIN_VA, PROC_MAX_VA]$. For
now, in the RISCV-32 architecture, `PROC_MAX_VA` and `PROC_MAX_VA=0x80000000`.

Function `exec()` maps code and data from address `PROC_MAX_VA=0`. The user
stack is one page memory and it is mapped from `PROC_MAX_VA - PAGE_SIZE`.

## Trap handling

Now we can have user (the CPU is running in U-mode) and kernel (the CPU is
running in S-mode) mode interrupts.

In some architectures, like RISCV, the CPU doesn't change the stack
automatically in a trap. In a trap in user mode the CPU is using the user mode
stack. When a trap occurs, we have to save the CPU state (or *trap frame*) in
the kernel mode task stack.

To do that, before returning to user mode process, the kernel mode
stack start address is saved in a CPU special register (`sscratch` in RISCV).

We now have two low level ISRs:
- `s_trap`: Handle traps when CPU is in supervisor mode. On a trap it calls to `kernel_trap()`.
- `u_trap`: Handle traps when CPU is in user mode. On a trap it calls to
  `user_trap()`.

Now, in `user_trap()` we have to handle syscall traps and dispatch (via
`syscall`) the correspnding syscall function.

On return of a user mode trap, the routine `u_trap_ret()` is called (from
`return_to_user_mode()`). This restore process CPU saved values from stack and
return to user mode.

## System calls

We define a small set of syscalls (see `syscall.c`):

| Syscall                         | Description                                |
| ------------------------------- | ------------------------------------------ |
| `int exit(int exit_code)`       | Process exits.                             |
| `int getpid(void)`              | Get process identifier.                    |
| `int console_puts(char *str)`   | Print string by console.                   |
| `int console_putc(char c)`      | Print the character *c* string by console. |
| `int console_getc(void)`        | Read a character from console.             |
| `int sleep(int ticks)`          | Wait (suspend process) by given ticks      |

### User mode edos library

User programs should be linked with edos library. In `user` directory there is
the `init` program. The edos static library is build from `edoslib.c` and
`usys.s`. In this last assembly file, there are defined the syscalls in user mode.

In RISCV, each syscall is implemented by loading the syscall number in register
`a7`. The code generated by compiler will put specific syscall function
arguments en register `a0, ...`.

The `Makefile` will compile and link user programs with an *entry point of 0*
which is the `start()` function defined in `edoslib.c` (it should be the first
function defined).

## EFS: A custom embedded file system

We need a filesystem to store user program and data files. In this project we
built a very simple filesystem. The filesystem image can to be linked to kernel
kernel as binary data and so loaded by QEMU on boot. This is a type of RAM
filesystem (not in disc).

The build system (see `Makefile`) contain rules to filesystem creation.
For each user programs a *raw binary* with `.bin` suffix is generated.

creates the filesystem image as a C source
file (`efsfiles.c`) and copy it to kernel code directory. This source file is
compiled and linked with the rest of kernel source files.

The shell script `mkefs.sh` build the filesystem image (the C source file
`efsfiles.c`) from `.bin` binary and data files received in command line
arguments using the `xxd` utility.

Then, the script generate an array of `struct file` values. Each entry contains
the file name, file type (program or data), a pointer to binary data array and
its length.It is the filesystem *root directory*.

The function `struct file* efs_file(char *file_name)` in `efs.c` return the
pointer to corresponding struct file or null if doesn't exist.

In `task.c`, the function `load_program(pgtbl, file_name)` (called by `exec()`)
load (copy) the program binary data into new allocated memory and map the
process code and static data.

## Exercises

1. Boot edos and see init execution.
2. Analyze the kernel code:
   - In `tasks.c/h`: Functions `create_process()` and `exec()`.
   - In `trap.c` and `trap.s`: See the trap handlers.
   - The syscalls module.
3. Analyze how user programs are compiled and linked. Also analyze how the
   `mkefs.sh` script creates `efsfiles.c`.
4. Describe how is the execution path from process creation to process code
   execution starts.
5. Modify `init.c` to generate a page fault.
6. Add the syscall `time` returning the value of `ticks` elapsed from boot.
   
